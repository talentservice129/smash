
<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, user-scalable=no" />
    <link rel="stylesheet" href="style.css" />
    <link
      href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/css/bootstrap.min.css"
      rel="stylesheet"
      integrity="sha384-T3c6CoIi6uLrA9TneNEoa7RxnatzjcDSCmG1MXxSR1GAsXEV/Dwwykc2MPK8M2HN"
      crossorigin="anonymous"
    />
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=Pacifico&display=swap"
      rel="stylesheet"
    />
    <link rel="stylesheet" href="button.css" />
    <style>
      * {
        z-index: 1;
      }

      body {
        margin: 0;
        padding: 0;
        /* background-image: url(bg.png); */
      }

      @media screen and (orientation: landscape) {
        body {
          transform: rotate(-90deg);
          transform-origin: top left;
          width: 100vh;
          height: 100vw;
          overflow-x: hidden;
          position: absolute;
          top: 100%;
          left: 0;
        }
      }

      @keyframes rotate {
        0% {
          border-image: linear-gradient(
              0deg,
              #00ffff 50%,
              #00ffff 20%,
              #b818e0,
              #8921f1
            )
            30;
          /*box-shadow: inset 5px 0px 15px 5px #00ffff7d, 
            inset 0 5px 15px 5px #B818E07d,
            inset 5px 0px 5px 5px #8921f17d;*/
        }
        25% {
          border-image: linear-gradient(
              90deg,
              #00ffff 50%,
              #00ffff 20%,
              #b818e0,
              #8921f1
            )
            30;
          /*box-shadow: inset 5px 0px 15px 5px #00ffff7d, 
            inset 5px 0px 15px 5px #B818E07d,
            inset 0px 5px 5px 5px #8921f17d;*/
        }
        50% {
          border-image: linear-gradient(
              180deg,
              #00ffff 50%,
              #00ffff 20%,
              #b818e0,
              #8921f1
            )
            30;
          /*box-shadow: inset 5px 0px 15px 5px #00ffff7d, 
            inset 5px 5px 15px 5px #B818E07d,
            inset 5px 5px 5px 5px #8921f17d;*/
        }
        75% {
          border-image: linear-gradient(
              270deg,
              #00ffff 50%,
              #00ffff 20%,
              #b818e0,
              #8921f1
            )
            30;
          /*box-shadow: inset 5px 0px 15px 5px #00ffff7d, 
            inset 0 0px 15px 5px #B818E07d,
            inset 0px 0px 5px 5px #8921f17d;*/
        }
        100% {
          border-image: linear-gradient(
              0deg,
              #00ffff 50%,
              #00ffff 20%,
              #b818e0,
              #8921f1
            )
            30;
          /*box-shadow: inset 5px 0px 15px 5px #00ffff7d, 
            inset 0 5px 15px 5px #B818E07d,
            inset 5px 0px 5px 5px #8921f17d; */
        }
      }

      canvas {
        width: 95%;
        max-height: calc(100% - 131px);
        margin: 0 auto;
        display: block;
        position: relative;
        object-fit: contain;
        /* background-color: rgb(0 0 0 / 83%); */
        /* border-image: linear-gradient(0deg,#00FFFF 50%,#00FFFF 20%, #B818E0,#9544E6) 30; */
        box-shadow: inset 0 0 10px 5px #00ffff69, 0 0 10px 5px #00ffff69,
          inset 0px 0px 10px 5px #b818e069, 0px 0px 10px 5px #b818e069,
          inset 0px 0px 10px 5px #8921f169, 0px 0px 10px 5px #8921f169;
        /* box-shadow: inset 5px 0px 15px 5px #00ffff7d, 
            inset 0 5px 15px 5px #B818E07d,
            inset 5px 0px 5px 5px #8921f17d; */
        /* box-shadow: linear-gradient(0deg,#00FFFF 50%,#00FFFF 20%, #B818E0,#8921f1 30); */
        border-width: 4px;
        border-style: solid;
        animation-name: rotate;
        animation-duration: 4.5s;
        animation-iteration-count: infinite;
        animation-timing-function: ease-in-out;
      }

      img {
        /* background-blend-mode: color-dodge; */
        /* background-color: #020202ab; */
      }

      button {
        /* border-radius: 5px; */
        font-size: 1.5em;
        display: block;
        margin: 10 auto;
        position: relative;
        top: 3rem;
        /* background-color: #8921f1; */
        /* color: rgb(204, 204, 253); */
        /* padding: 1rem; */
        font-size: 2rem;
        /* border: 0.25em #8921f1 solid; */
        /* border: none; */
        border-radius: 0.3em !important;
      }

      @media screen and (max-width: 710px) {
        /* Surface Pro 7, Surface Duo */
        /* canvas {
          width: 90% !important;
          height: auto !important;
          top: 5vh !important;
        } */
        .control {
          display: flex;
          flex-direction: column;
        }
      }
      @media screen and (max-width: 1800px) {
        /* canvas {
          height: 65%;
          top: 0.5rem;
        } */
      }

      .control {
        display: flex;
        width: 100%;
        justify-content: center;
        align-items: center;
      }

      .button-30 {
        position: static;
      }

      .chal {
        width: 100%;
        display: flex;
        flex-direction: column;
        margin: auto 0;
        height: 100%;
      }

      p {
        color: aliceblue;
      }
      .imgsr {
        height: 40px;
        background: transparent;
      }
      div button img {
        height: 25px;
        /* margin-left: -6px; */
      }
      .imgds {
        border-radius: 50%;
        position: static;
        background: transparent;
        border: none;
        margin: 0 0 15px 0;
      }
      .imgds1 {
        border-radius: 50%;
        position: static;
        background: transparent;
        border: none;
        margin: 0 0 15px;
      }
      .divo {
        height: 50px;
        background-color: transparent;
      }

      .divo1 {
        height: 27px;
        padding: 3px;
        border-radius: 50%;
        border: 2px solid aliceblue;
        background-color: transparent;
      }
      p {
        color: #8921f1;
      }
      .sound {
        display: flex;
        flex-direction: column;
        justify-content: space-between;
        margin-bottom: 50px;
        margin-left: 25px;
        margin-right: 25px;
      }
      .sound button img {
        background-color: transparent;
      }
      .buttoncl {
        background-color: transparent;
        display: flex;
        flex-direction: row;
        width: 175px;
      }
      .mt-10 {
        margin-top: -45px;
      }
      .buttoncl p {
        margin-bottom: 0 !important;
        margin-left: 25px;
        color: aliceblue !important;
      }
      dialog {
        background-color: #123048;
        border: 4px solid #aaf1fe;
        border-radius: 1rem;
        overflow: hidden;
        box-shadow: 0 0 10px #aaf1fe;
        height: 310px !important;
      }

      .leb {
        /* margin-left: 25px; */
      }
      .main-btns {
        display: flex;
        justify-content: flex-end;
      }
      .menuLink {
        text-decoration: none;
      }
    </style>
  </head>

  <body>
    <audio id="brickTouchSound" onclick="changeText()">
      <source src="./balls_touches_the_block.wav" type="audio/mpeg" />
      Your browser does not support the audio element.
    </audio>
    <audio id="brickBreakSound">
      <source src="./230927202-stone-drop-soft-surface-6.wav" type="audio/mpeg" />
      Your browser does not support the audio element.
    </audio>
    <audio id="bombBrickBreakSound">
      <source src="./bomb.mp3" type="audio/mpeg" />
      Your browser does not support the audio element.
    </audio>
    <audio id="bgMusic" loop>
      <source
        src="./Dosi & Aisake - Cruising  Lofi  NCS - Copyright Free Music.mp3"
        type="audio/mpeg"
      />
      Your browser does not support the audio element.
    </audio>

    <img
      style="position: absolute; width: 100%; height: 100%; z-index: -1"
      src=".\4\4\Untitled-1-09.png"
    />
    <img
      src="./Untitled-1-06-min-min.png"
      alt="Ball"
      width="20"
      height="20"
      id="scream"
      style="display: none"
    />
    <img
      src="./additional_ball.png"
      alt="Ball"
      width="20"
      height="20"
      id="water"
      style="display: none"
    />
    <img
      src="./danger.png"
      alt="Bomb"
      width="20"
      height="20"
      id="bomb"
      style="display: none;"
    />
    <div
      style="
        background: url('.\4\4\Untitled-1-09.png');
        position: absolute;
        width: 100%;
        height: 100%;
        z-index: -1;
      "
    ></div>
    <div class="chal">
      <dialog>
        <button
          autofocus
          class="button-88 button buttoncl mt-10"
          onclick="dialog.close()"
        >
          <img src="./play-button-arrowhead.png" alt="close" />
          <p>Continue</p>
        </button>
        <div class="sound">
          <button
            class="button-88 button soundBtn buttoncl"
            role="button"
            onclick="let soundImage = document.getElementById('soundImage');var audioElementTouch = document.getElementById('brickTouchSound');
            var audioElementBreak = document.getElementById('brickBreakSound');if (soundImage.src.endsWith('no-sound.png')) {
            soundImage.src = 'volume.png';
            audioElementTouch.muted = false;
            audioElementBreak.muted = false;
            gameManager.scoreStorage.setSound(true);
          } else {
            audioElementTouch.muted = true;
            audioElementBreak.muted = true;
            soundImage.src = 'no-sound.png';
            gameManager.scoreStorage.setSound(false);
          }"
          >
            <img src="./volume.png" id="soundImage" alt="sound" />
            <p>Sound</p>
          </button>
          <button
            class="button-88 button buttoncl leb musicBtn"
            role="button"
            onclick="let musicImage = document.getElementById('musicImage');var bgMusic = document.getElementById('bgMusic');if (musicImage.src.endsWith('no-music.png')) {
            musicImage.src = 'music.png';
            bgMusic.play();
            gameManager.scoreStorage.setMusic(true);
          } else {
            musicImage.src = 'no-music.png';
            bgMusic.pause();
            gameManager.scoreStorage.setMusic(false);
          } "
          >
            <!-- onclick="musicImage.src = 'volume.png'" -->
            <img src="./music.png" id="musicImage" alt="music" />
            <p>Music</p>
          </button>
          <button class="button-88 button buttoncl leb" role="button">
            <img src="./burger-bar.png" alt="sound" />
            <a class='menuLink' href='menu.html'>
              <p>Menu</p>
            </a>
          </button>
        </div>
        <!-- <p>This modal dialog has a groovy backdrop!</p> -->
      </dialog>
      <div class="main-btns">
        <button
          class="imgds1"
          role="button"
          onclick="gameManager.downBalls();"
        >
          <img class="divo1" src="./sync.png" id="refreshBtn" alt="pause" />
        </button>
        <button class="imgds" role="button" onclick="dialog.showModal();">
          <img class="divo" src="./ShutDown.png" alt="pause" />
        </button>
      </div>

      <canvas
        id="canvas"
      ></canvas>
      <div class="control" style="display: none;">
        <input
          type="range"
          title="noopener"
          min="0"
          max="1000"
          value="500"
          id="myRange"
          class="range blue slider"
        />
        <button
          class="button-30"
          role="button"
          onclick="gameManager.downBalls()"
        >
          <img src="./sync.png" alt="Drop Down" class="imgsr" />
        </button>
      </div>
    </div>
    <!-- <button  id="btn">Drop Down</button> -->
    <script>
      function randomInt(...args) {
        if (args.length === 1) {
          const [n] = args;
          return Math.ceil(Math.random() * n);
        }

        if (args.length === 2) {
          const [start, end] = args;

          if (start > end) throw Error("시작값이 끝값보다 큼");

          return Math.ceil(Math.random() * (end - start)) + start;
        }
      }

      function random(...args) {
        if (args.length === 1) {
          const [n] = args;
          return Math.random() * n;
        }

        if (args.length === 2) {
          const [start, end] = args;

          if (start > end) throw Error("시작값이 끝값보다 큼");

          return Math.random() * (end - start) + start;
        }
      }

      const range = function (n, m) {
        if (arguments.length === 1)
          return Array.from({ length: n }).map((_, i) => i);

        if (arguments.length === 2) {
          if (n === m) return [n];
          else if (n < m) {
            return Array.from({ length: m - n + 1 }).map((_, i) => i + n);
          } else {
            return Array.from({ length: n - m + 1 }).map(
              (_, i) => m - i + (n - m)
            );
          }
        }
      };

      function normalize(n) {
        return n < 0 ? -1 : n > 0 ? 1 : 0;
      }

      function clamp(v, min, max) {
        return Math.max(min, Math.min(max, v));
      }

      function between(v, min, max) {
        return min <= v && v <= max;
      }

      const delay = (n) => new Promise((r) => setTimeout(r, n));
    </script>

    <script>
      /**
       * Vector Library
       **/
      class Vector {
        constructor(x = 0, y = 0) {
          this.x = x;
          this.y = y;
        }

        add(v) {
          this.x += v.x;
          this.y += v.y;
        }

        sub(v) {
          this.x -= v.x;
          this.y -= v.y;
        }

        mult(n) {
          this.x *= n;
          this.y *= n;
        }

        mag() {
          return Math.sqrt(this.x * this.x + this.y + this.y);
        }

        get() {
          return new Vector(this.x, this.y);
        }

        normalize() {
          this.x = normalize(this.x);
          this.y = normalize(this.y);
        }

        copy() {
          return new Vector(this.x, this.y);
        }
      }

      Vector.mult = (v, n) => new Vector(v.x * n, v.y * n);

      Vector.div = (v, n) => new Vector(v.x / n, v.y / n);
    </script>

    <script>
      /**
       *   Canvas Library
       **/
      const canvas = document.getElementById("canvas");
      const ctx = canvas.getContext("2d");

      const width = 700;
      const height = 1080;

      const uiOffsetY = 80;

      canvas.width = width;
      canvas.height = height;

      function line(x1, y1, x2, y2) {
        ctx.beginPath();
        // ctx.strokeStyle = color;
        ctx.lineWidth = 5;
        ctx.moveTo(x1, y1);
        ctx.lineTo(x2, y2);

        const gradient = ctx.createLinearGradient(x1, y1, x2, y2);
        gradient.addColorStop(0, "#ff00ffcc");
        gradient.addColorStop(1, "#00ffffcc");
        ctx.strokeStyle = gradient;
        ctx.stroke();
      }

      function line1(x1, y1, x2, y2) {
        ctx.beginPath();
        // ctx.strokeStyle = color;
        ctx.lineWidth = 5;
        ctx.moveTo(x1, y1);
        ctx.lineTo(x2, y2);

        const gradient = ctx.createLinearGradient(x1, y1, x2, y2);
        gradient.addColorStop(0, "#00ffffcc");
        gradient.addColorStop(1, "#ff00ffcc");
        ctx.strokeStyle = gradient;
        ctx.stroke();
      }

      function dashLine(x1, y1, x2, y2, color = "#ff00ff") {
        ctx.beginPath();
        ctx.setLineDash([1, 15]);
        ctx.strokeStyle = color;
        ctx.lineCap = "round";

        // Calculate the angle of the line
        const angle = Math.atan2(y2 - y1, x2 - x1);

        // Calculate the new x2 and y2 coordinates to make the line 800px long
        const distance = 1000;
        const newX2 = x1 + distance * Math.cos(angle);
        const newY2 = y1 + distance * Math.sin(angle);

        ctx.moveTo(x1, y1);
        ctx.lineTo(newX2, newY2);
        ctx.stroke();
        ctx.setLineDash([]);
      }

      function rect(x, y, w, h) {
        ctx.beginPath();
        ctx.rect(x, y, w, h);
        ctx.strokeStyle = "#000";
        ctx.stroke();
        ctx.closePath();
      }

      function fillRect(x, y, w, h, color = "#171717") {
        ctx.save();
        ctx.beginPath();
        ctx.fillStyle = color;
        ctx.fillRect(x, y, w, h);
        ctx.stroke();
        ctx.closePath();
        ctx.restore();
      }

      function circle(x, y, r, color = "#000") {
        ctx.save();
        ctx.beginPath();
        ctx.arc(x, y, r, 0, Math.PI * 2);
        ctx.lineWidth = 3;
        ctx.fillStyle = color;
        ctx.strokeStyle = color;
        ctx.fill();
        ctx.stroke();
        ctx.closePath();
        ctx.restore();
      }

      function clear() {
        ctx.clearRect(0, 0, width, height);
      }

      function shuffle(arr) {
        return arr.sort(() => Math.random() - 0.5);
      }
    </script>

    <script>
      /**
       *   User Code
       **/
      const POWER = 0.3;

      const Mouse = { position: new Vector(0, 0) };

      class BallLine {
        constructor() {}
        display(state) {
          if (!state.ballMoving && !state.brickMoving && state.ballPos) {
            dashLine(
              state.ballPos.x,
              state.ballPos.y,
              Mouse.position.x,
              Mouse.position.y,
              Math.min(Mouse.position.y, 720)
            );
          }
        }
      }

      class Ball {
        constructor(mass, x, y) {
          this.position = new Vector(x, y);
          this.velocity = new Vector(0, 0);
          this.acceleration = new Vector(0, 0);
          this.mass = mass;
          this.r = this.mass * 8;
          this.showDirection = true;
        }

        setOnStop(f) {
          this.onStop = f;
        }

        applyForce(force) {
          const f = Vector.div(force, this.mass);
          this.acceleration.add(f);
        }

        update() {
          this.velocity.add(this.acceleration);
          this.position.add(this.velocity);

          this.acceleration.mult(0);
        }

        move(direction) {
          if (direction === "right") this.applyForce(new Vector(20, 0));
          else if (direction === "left") this.applyForce(new Vector(-20, 0));
        }

        stop() {
          this.velocity = new Vector(0, 0);
          this.showDirection = true;
          this.onStop(this);
          this.downing = false;
        }

        down() {
          this.downing = true;
          this.velocity = new Vector(0, 30);
        }

        shoot(mousePos) {
          this.showDirection = false;
          const constantSpeed = 25;
          let angle;

          // Check if the mouse position is on the extreme right
          if (mousePos.x >= width - 0.5) {
            // Calculate the angle to shoot the ball towards the right side
            angle = Math.PI / 2; // 90 degrees in radians
          } else {
            // Calculate the angle based on the mouse position
            const opposite = mousePos.y - this.position.y;
            const adjacent = mousePos.x - this.position.x;
            angle = Math.atan2(opposite, adjacent);
          }

          const force = this.calcBallVelocity(angle, constantSpeed);
          this.applyForce(force);
        }

        calcBallVelocity(angle, constantSpeed) {
          return new Vector(
            constantSpeed * Math.cos(angle),
            constantSpeed * Math.sin(angle)
          );
        }

        angle(mousePos) {
          const opposite = mousePos.y - this.position.y;
          const adjacent = mousePos.x - this.position.x;
          const angle = Math.atan2(opposite, adjacent);

          return angle;
        }

        display() {
          // const canvas = document.getElementById("myCanvas");
          // const ctx = canvas.getContext("2d");
          const img = document.getElementById("scream");

          // Define the new width and height for the image
          const newWidth = 150; // Set your desired width
          const newHeight = 100; // Set your desired height
          const marginBottom = -50;
          const marginLeft = -81;

          const yPosWithMargin = this.position.y + marginBottom;
          const xPosWithMargin = this.position.x + marginLeft;

          ctx.save();
          ctx.fillStyle = '#6f09a5';
          ctx.beginPath();
          ctx.ellipse(this.position.x , this.position.y, this.r, this.r, 0, 0, 2 * Math.PI);
          ctx.fill();
          ctx.fillStyle = '#7d0cc9';
          ctx.beginPath();
          ctx.ellipse(this.position.x, this.position.y - this.r * 0.125, this.r * 0.875, this.r * 0.875, 0, 0, 2 * Math.PI);
          ctx.fill();
          ctx.fillStyle = '#a055d4';
          ctx.beginPath();
          ctx.ellipse(this.position.x - this.r * 0.15, this.position.y - this.r * 0.25, this.r * 0.55, this.r * 0.55, 0, 0, 2 * Math.PI);
          ctx.fill();
          ctx.fillStyle = "#b986dc";
          ctx.beginPath();
          ctx.ellipse(this.position.x - this.r * .35, this.position.y - this.r * 0.02, this.r * 0.125, this.r * 0.125, 0, 0, 2 * Math.PI);
          ctx.fill();
          ctx.beginPath();
          ctx.ellipse(this.position.x - this.r * .25, this.position.y - this.r * 0.45, this.r * 0.2, this.r * 0.2, 0, 0, 2 * Math.PI);
          ctx.fill();
          ctx.restore();
        }

        collideWith(brick) {
          if (this.downing) return false;

          const { x, y } = this.position;
          const r = this.r;

          const closestX = clamp(x, brick.x, brick.x + brick.w);
          const closestY = clamp(y, brick.y, brick.y + brick.h);

          const distanceX = x - closestX;
          const distanceY = y - closestY;
          const distanceSquared = distanceX * distanceX + distanceY * distanceY;

          const collided = distanceSquared < r * r;

          if (!collided) return false;

          if (
            closestY === brick.y &&
            between(closestX, brick.x - r + 5, brick.x + brick.w + r - 5) // Change the +/- 3 to +/- 5
          ) {
            this.velocity.y *= -1;
            this.position.y = closestY - r;
          } else if (
            closestY === brick.y + brick.h &&
            between(closestX, brick.x - r + 5, brick.x + brick.w + r - 5) // Change the +/- 3 to +/- 5
          ) {
            this.velocity.y *= -1;
            this.position.y = closestY + r;
          } else if (
            closestX === brick.x &&
            between(closestY, brick.y - r + 5, brick.y + brick.h + r - 5) // Change the +/- 3 to +/- 5
          ) {
            this.velocity.x *= -1;
            this.position.x = closestX - r;
          } else if (
            closestX === brick.x + brick.w &&
            between(closestY, brick.y - r + 5, brick.y + brick.h + r - 5) // Change the +/- 3 to +/- 5
          ) {
            this.velocity.x *= -1;
            this.position.x = closestX + r;
          }

          return true;
        }

        collideWithBonusBall(bonusBall) {
          if (this.downing) return false;

          const x = this.position.x - bonusBall.x;
          const y = this.position.y - bonusBall.y;
          const r = this.r;
          const collided = 2 * r >= Math.sqrt(x * x + y * y);

          return collided;
        }

        checkEdges() {
          if (this.position.x > width) {
            this.position.x = width;
            this.velocity.x *= -1;
          } else if (this.position.x < 0) {
            this.position.x = 0;
            this.velocity.x *= -1;
          }

          if (this.position.y > height - 100) {
            this.velocity.y *= -1;
            this.position.y = height - 100;
            this.stop();
          } else if (this.position.y < 100) {
            this.velocity.y *= -1;
            this.position.y = 100;
          }
        }
      }

      const brickColors = [
        [255, 165, 0, 255, 140, 0, 255, 120, 0],
        [255, 0, 255, 255, 20, 147, 255, 85, 255],
        [50, 205, 50, 34, 139, 34, 0, 128, 0],
        [0, 0, 255, 0, 0, 220, 0, 0, 185],
        [0, 255, 0, 0, 200, 0, 0, 150, 0],
        [128, 0, 128, 160, 32, 240, 128, 0, 255],
        [255, 255, 0, 255, 235, 0, 255, 215, 0],
        [255, 0, 0, 255, 40, 40, 255, 80, 80],
        [255, 0, 255, 255, 20, 147, 255, 85, 255],
        [0, 255, 255, 0, 173, 239, 0, 128, 255],
        [255, 215, 0, 255, 180, 0, 255, 150, 0],
        [200, 162, 200, 215, 175, 215, 230, 188, 230],
        [135, 206, 250, 119, 158, 203, 100, 149, 237],
        [50, 205, 50, 0, 128, 0, 124, 252, 0],
        [255, 105, 180, 255, 20, 147, 255, 69, 147],
        [0, 0, 139, 0, 0, 160, 0, 0, 181],
        [255, 255, 140, 255, 255, 160, 255, 255, 181],
        [188, 143, 143, 205, 92, 92, 220, 20, 60],
        [0, 173, 239, 0, 139, 209, 0, 116, 175],
        [152, 251, 152, 124, 252, 124, 100, 220, 100],
        [218, 112, 214, 240, 128, 128, 186, 85, 211],
        [255, 127, 80, 255, 99, 71, 255, 69, 0],
        [0, 255, 255, 0, 235, 235, 0, 205, 205],
        [255, 255, 140, 255, 255, 150, 255, 255, 160],
        [224, 17, 95, 221, 30, 80, 215, 0, 64],
        [255, 153, 18, 255, 135, 0, 255, 100, 0],
        [0, 229, 170, 0, 190, 138, 0, 154, 112],
        [175, 130, 190, 185, 140, 200, 195, 150, 210],
        [251, 206, 177, 255, 160, 122, 255, 127, 80],
        [182, 102, 210, 200, 150, 215, 186, 85, 211],
        [102, 205, 170, 70, 130, 180, 0, 128, 128],
        [204, 255, 0, 173, 255, 47, 154, 205, 50],
        [250, 128, 114, 233, 150, 122, 240, 130, 140],
        [0, 123, 167, 0, 102, 204, 0, 139, 139],
        [111, 45, 168, 130, 102, 153, 148, 96, 131],
        [255, 165, 0, 255, 140, 0, 255, 120, 0],
        [176, 224, 230, 173, 216, 230, 173, 216, 230],
        [218, 112, 214, 206, 144, 203, 186, 85, 211],
        [64, 224, 208, 70, 130, 180, 0, 128, 128],
        [255, 0, 255, 245, 0, 245, 238, 0, 238],
        [255, 255, 51, 255, 245, 61, 255, 235, 71],
        [0, 201, 87, 0, 168, 107, 0, 145, 100],
        [251, 111, 66, 255, 69, 0, 255, 85, 0],
        [135, 206, 235, 119, 158, 203, 100, 149, 237],
        [135, 206, 235, 119, 158, 203, 100, 149, 237],
        [255, 239, 184, 255, 200, 87, 255, 168, 44],
        [44, 117, 255, 20, 90, 255, 0, 0, 255],
        [204, 51, 153, 221, 44, 153, 238, 32, 77],
        [50, 205, 50, 34, 139, 34, 0, 128, 0],
        [255, 102, 102, 255, 51, 51, 255, 26, 26]
      ];

      class Brick {
        constructor(n, x, y, minY = Infinity) {
          this.n = n;
          this.start = n;

          this.x = x * 100;
          this.y = Math.min(y * 100 + uiOffsetY, minY);
          this.w = 100;
          this.h = 100;
        }

        shouldMoveDown(state) {
          return this.y < 100 * (state.level - this.start + 1) + uiOffsetY;
        }

        update(state) {
          if (this.shouldMoveDown(state)) {
            this.y = Math.min(
              this.y + 10,
              100 * (state.level - this.start + 1) + uiOffsetY
            );
          }
        }

        color(level) {
          const percentage = ((level - this.n) / level) * 30;
          return `hsl(${percentage}, ${100 - percentage}%, 63%)`;
        }
        colorGradient(state) {
          const gradient = ctx.createRadialGradient(
            this.x + this.w / 2,
            this.y + this.h / 2,
            0,
            this.x + this.w / 2,
            this.y + this.h / 2,
            this.w / 2
          );

          // Change this line to set the background color to dark green
          gradient.addColorStop(0, "rgb(250, 183, 38)");
          return gradient;
        }
        drawGoldenGlow(ctx, x, y, w, h) {
          const centerX = x + w / 2;
          const centerY = y + h / 2;

          // Create a radial gradient for the glow
          const gradient = ctx.createRadialGradient(
            centerX,
            centerY,
            0,
            centerX,
            centerY,
            w / 2
          );

          // Add color stops to simulate the glow
          gradient.addColorStop(0, 'rgba(255, 223, 0, 0.4)');
          gradient.addColorStop(1, 'rgba(255, 223, 0, 0)');

          // Set the gradient as the fill style
          ctx.fillStyle = gradient;

          // Fill the rectangle with the gradient
          ctx.fillRect(x, y, w, h);
        }

        drawGlowBorder(
          ctx,
          x,
          y,
          w,
          h,
          borderWidth,
          borderColor,
          glowColor,
          glowBlur
        ) {
          // Save the current canvas state
          ctx.save();

          // Draw the rectangular shape (without a border)
          ctx.fillStyle = glowColor;
          ctx.fillRect(x, y, w, h);

          // Set the shadow properties for the glow effect
          ctx.shadowBlur = glowBlur;
          ctx.shadowColor = borderColor;

          // Draw the border (with a glow effect)
          ctx.strokeStyle = borderColor;
          ctx.lineWidth = borderWidth;
          ctx.strokeRect(x, y, w, h);

          // Restore the canvas state to remove the shadow from other elements
          ctx.restore();
        }

        display(state) {
          const centerX = this.x + this.w / 2;
          const centerY = this.y + this.h / 2;
          const spaceInside = 8;
          const innerWidth = this.w - 2 * spaceInside;
          const innerHeight = this.h - 2 * spaceInside;

          const innerX = centerX - innerWidth / 2;
          const innerY = centerY - innerHeight / 2;

          // Set the shadow properties to create the glow effect
          // ctx.shadowBlur = 1; // Adjust the blur radius for the glow

          // Fill the inner rectangle with the gradient and the glow effect
          // ctx.fillStyle = this.colorGradient(state.level);
          ctx.fillStyle = `rgb(${(255 / 100) * (this.n + 2) * 5}, ${155 - (255 / 100) * (this.n +2) * 5}, ${(255 / 100) * (this.n +2)})`;
          const min = 1;
          const max = 49;
          const randomInt = Math.floor(Math.random() * (max - min + 1)) + min;
          let s = randomInt;

          let a,
            b,
            c,
            d = 55,
            e = 55,
            f = 55,
            g = 1,
            h,
            i,
            j,
            k,
            l,
            m;
          let chlvl = this.n % 50;
          [a,b,c,h,i,j,k,m,l] = brickColors[chlvl];

          // Create a radial gradient for opacity
          const radialGradient = ctx.createRadialGradient(
            centerX,
            centerY,
            0,
            centerX,
            centerY,
            innerWidth / 2
          );
          radialGradient.addColorStop(0, `rgba(${d}, ${e}, ${f}, ${g})`); // Less opaque in the center
          radialGradient.addColorStop(1, `rgba(${a}, ${b}, ${c}, 0.75)`);
          // radialGradient.addColorStop(0, `rgba(${(255 / 100) * (this.n + 2) * 5}, ${155 - (255 / 100) * (this.n +2) * 5}, ${(255 / 100) * (this.n +2)}, 0.44)`); // Less opaque in the center
          // radialGradient.addColorStop(1, `rgba(${(255 / 100) * (this.n + 2) * 5}, ${155 - (255 / 100) * (this.n +2) * 5}, ${(255 / 100) * (this.n +2)}, 1.0)`); // More opaque towards the edges

          // Set the radial gradient as the fill style for the inner rectangle
          ctx.fillStyle = radialGradient;

          // ctx.globalAlpha = 0.5; // Change the value to set the desired opacity

          // ctx.fillRect(innerX, innerY, innerWidth, innerHeight);

          ctx.fillRect(innerX, innerY, innerWidth, innerHeight);

          // ctx.globalAlpha = 1;

          ctx.strokeStyle = `rgba(${h}, ${i}, ${j}, 1.0)`;
          ctx.shadowColor = `rgba(${k}, ${l}, ${m}, 1.0)`;
          ctx.lineWidth = 0; // Increase the border width if needed
          ctx.shadowBlur = 3; // Adjust the blur radius for the glow
          // var grd = ctx.createRadialGradient(
          //   this.w / 2,
          //   this.w / 2,
          //   0.3,
          //   this.w / 2,
          //   this.w / 2,
          //   this.w / 30
          // );
          // grd.addColorStop(0, `rgba(${d}, ${e}, ${f}, ${g})`); // Less opaque in the center
          // grd.addColorStop(1, `rgba(${a}, ${b}, ${c}, 0.75)`);
          // grd.addColorStop(0, "#fff1f1");
          // grd.addColorStop(1, "#ff5b5b");
          // ctx.fillStyle = grd;

          ctx.save();
          ctx.translate(this.x, this.y - this.w / 2);
          ctx.beginPath();
          ctx.ellipse(
            this.w / 2,
            this.w / 2,
            this.w / 18,
            this.w / 3,
            Math.PI / 2,
            0,
            Math.PI * 2,
            false
          );
          ctx.fill();
          ctx.restore();
          ctx.save();

          ctx.translate(this.x, this.y + this.w / 2);
          ctx.beginPath();
          ctx.ellipse(
            this.w / 2,
            this.w / 2,
            this.w / 18,
            this.w / 3,
            Math.PI / 2,
            0,
            Math.PI * 2,
            false
          );
          ctx.fill();
          ctx.restore();

          ctx.strokeStyle = `rgba(${h}, ${i}, ${j}, 1.0)`;

          ctx.lineWidth = 5; // Increase the border width if needed
          ctx.shadowBlur = 4;

          ctx.strokeRect(this.x, this.y, this.w, this.h);

          ctx.strokeStyle = "#fff";
          ctx.lineWidth = 1; // Increase the border width if needed
          ctx.shadowBlur = 0;
          ctx.strokeRect(this.x, this.y, this.w, this.h);

          // Add text inside the rectangle
          ctx.fillStyle = "#fff";
          ctx.lineWidth = 3;
          ctx.font = "20px Arial";
          ctx.textBaseline = "middle";
          ctx.textAlign = "center";
          ctx.fillText(this.n, this.x + this.w / 2, this.y + this.h / 2);
          ctx.textAlign = "start";
          // ctx.globalAlpha = 0.5; // Change the value to set the desired opacity
        }

        hit() {
          this.n--;
          if (this.n <= 0) {
            var audioElement = document.getElementById("brickBreakSound");
            audioElement.play(); // Play the breaking sound
            // this.broken = true;
          }
        }

        get broken() {
          return this.n <= 0;
        }

        get hitBottom() {
          return this.y >= height - uiOffsetY - 80;
        }
      }

      class BombBrick extends Brick {
        constructor(n, x, y, minY) {
          super(n, x, y, minY);
          this.color = "#000000"; // Set the color to black
        }

        display(state) {
          // fillRect(this.x, this.y, this.w, this.h, this.color);

          const img = document.getElementById("bomb");
          // Add text inside the rectangle
          if (img.complete) {
            ctx.drawImage(
              img,
              this.x,
              this.y,
              this.w,
              this.h
            );
          } else {
            img.onload = function () {
              ctx.drawImage(
                img,
                this.x,
                this.y,
                this.w,
                this.h
              );
            };
          }
        }

        hit() {
          this.n--;
          if (this.n <= 0) {
            var audioElement = document.getElementById("bombBrickBreakSound");
            audioElement.play(); // Play the breaking sound
            // this.broken = true;
          }
        }
      }

      class BrickParticle {
        constructor(n, x, y) {
          const i = n % 5;
          const j = ~~(n / 4);

          this.w = 10;
          this.h = 10;
          this.location = new Vector(x + i * this.w, y + j * this.h);
          this.acceleration = new Vector(0, 0);
          this.velocity = new Vector(
            i > 2
              ? random(0, 0.5)
              : i === 2
              ? random(-0.5, 0.5)
              : random(-0.5, 0),
            random(1, 3)
          );
          this.lifespan = 255;
        }

        update() {
          this.velocity.add(this.acceleration);
          this.location.add(this.velocity);
          this.lifespan -= 4;
        }

        display() {
          fillRect(
            this.location.x,
            this.location.y,
            5,
            5,
            `hsla(293, 70%, 63%, ${this.lifespan / 255})`
          );
        }

        run() {
          this.update();
          this.display();
        }

        get isDead() {
          return this.lifespan < 0;
        }
      }

      class BrickParticleSystem {
        constructor(x, y) {
          this.origin = new Vector(x, y);
          this.particles = range(50).map((n) => new BrickParticle(n, x, y));
        }

        addParticle() {
          this.particles.push(new BrickParticle(this.origin));
        }

        run() {
          this.particles.forEach((particle) => particle.run());
        }

        get isDead() {
          return !this.particles.length || this.particles[0].isDead;
        }
      }

      class BrickParticleSystems {
        constructor() {
          this.particleSystems = [];
        }

        addParticleSystem(...bricks) {
          const newPs = bricks.map(({ x, y }) => new BrickParticleSystem(x, y));
          this.particleSystems.push(...newPs);
        }

        run() {
          this.particleSystems = this.particleSystems.filter(
            (ps) => !ps.isDead
          );
          this.particleSystems.forEach((ps) => ps.run());
        }
      }

      class BonusBall {
        constructor(n, x, y) {
          this.start = n;
          this.r = 16;
          this.x = x * 140 + 50;
          this.y = y * 120 + uiOffsetY;
          this.hit = false;

          //         this.effectR = 18;
          //         this.effectD = 0.1;
        }

        moveDownLittle(state) {
          this.y = Math.min(
            this.y + 10,
            120 * (state.level - this.start + 1) + uiOffsetY + 50
          );
        }

        update(state) {
          if (this.hit) this.y = Math.min(this.y + 50, height - 100);
          else this.moveDownLittle(state);

          if (this.hit && this.y === height - 100 && state.brickMoving) {
            if (this.x < state.ballPos.x) {
              this.x = Math.min(this.x + 30, state.ballPos.x);
            } else {
              this.x = Math.max(this.x - 30, state.ballPos.x);
            }
          }

          //         this.effectR += this.effectD;
          //         if (this.effectR > 28) this.effectR = 18;
        }

        display() {
          //   const borderWidth = 5; // Set the desired border width
          // const borderColor = "rgba(216,68,64,0.6)"; // Replace with your desired border color
          // const padding = 2;
          // const glowColor = "rgba(242,98,94, 0.7)"; // Replace with your circle color
          // const glowBlur = 25; // Adjust the blur radius for the glow

          // ctx.save();

          // // Apply the glow effect
          // ctx.shadowBlur = glowBlur;
          // ctx.shadowColor = glowColor;
          // circle(this.x, this.y, this.r - padding, "rgb(194,48,45)",glowColor);

          // // Draw a border around the circle
          // circle(this.x, this.y, this.r + borderWidth, borderColor);
          // ctx.restore();
          const img = document.getElementById("scream");

          // Define the new width and height for the image
          const newWidth = 150; // Set your desired width
          const newHeight = 100; // Set your desired height
          const marginBottom = -50;
          const marginLeft = -81;

          const yPosWithMargin = this.y + marginBottom;
          const xPosWithMargin = this.x + marginLeft;

          ctx.save();
          ctx.fillStyle = '#6f09a5';
          ctx.beginPath();
          ctx.ellipse(this.x , this.y, this.r, this.r, 0, 0, 2 * Math.PI);
          ctx.fill();
          ctx.fillStyle = '#7d0cc9';
          ctx.beginPath();
          ctx.ellipse(this.x, this.y - this.r * 0.125, this.r * 0.875, this.r * 0.875, 0, 0, 2 * Math.PI);
          ctx.fill();
          ctx.fillStyle = '#a055d4';
          ctx.beginPath();
          ctx.ellipse(this.x - this.r * 0.15, this.y - this.r * 0.25, this.r * 0.55, this.r * 0.55, 0, 0, 2 * Math.PI);
          ctx.fill();
          ctx.fillStyle = "#b986dc";
          ctx.beginPath();
          ctx.ellipse(this.x - this.r * .35, this.y - this.r * 0.02, this.r * 0.125, this.r * 0.125, 0, 0, 2 * Math.PI);
          ctx.fill();
          ctx.beginPath();
          ctx.ellipse(this.x - this.r * .25, this.y - this.r * 0.45, this.r * 0.2, this.r * 0.2, 0, 0, 2 * Math.PI);
          ctx.fill();
          ctx.restore();

          //         if (!this.hit)
          //             circle(this.x, this.y, this.effectR);
        }

        hitWithBall() {
          this.hit = true;
        }

        collideWith(ball) {
          const x = ball.position.x - this.x;
          const y = ball.position.y - this.y;
          const r = this.r;
          const collided = 2 * r >= Math.sqrt(x * x + y * y);

          if (collided) {
            this.hit = true;
          }
          return collided;
        }
      }

      class UI {
        constructor() {
        }

        display(state) {
          line(0, uiOffsetY, width, uiOffsetY);
          line1(0, height - uiOffsetY, width, height - uiOffsetY);

          this.showBallCount(state);
          this.showScore(state);
        }

        showScore(state) {
          ctx.fillStyle = "rgba(0,0,0,0.3)"; // You can use any valid CSS color here
          ctx.fillRect(0, 0, canvas.width, canvas.height / 14);
          // ctx.fillRect(515, 0, canvas.width / 3.5, canvas.height / 14);
          ctx.font = "24px 'Pacifico', cursive";
          ctx.fillStyle = "lightgray"; // You can use any valid CSS color here
          ctx.fillText(
            `current score: ${state.level}`,
            width - 175,
            uiOffsetY / 2 + 7
          );
          ctx.fillText(`max score: ${state.bestLevel}`, 20, uiOffsetY / 2 + 7);
        }

        showBallCount(state) {
          if (!state.ballMoving)
            ctx.fillText(
              `x${state.ballCount}`,
              state.ballPos.x - 10,
              height - 55
            );
        }

        // GameOver Styling
        gameOver() {
          // Clear the canvas
          ctx.clearRect(0, 0, width, height);

          // Draw the rectangle centered horizontally and vertically
          const rectWidth = Math.min(width * 0.4, 250); // Limit width to 600px or 80% of the screen width
          const rectHeight = Math.min(height * 0.3, 100); // Limit height to 400px or 60% of the screen height
          const rectX = (width - rectWidth) / 2;
          const rectY = (height - rectHeight) / 2;
          fillRect(rectX, rectY, rectWidth, rectHeight, "rgba(0,0,0,0)");

          // Draw the "Loss!" text
          ctx.font = "20px Arial"; // Adjust font size based on viewport width
          ctx.fillStyle = "aliceblue"; // Change color to black
          const textWidth = ctx.measureText("Loss!").width;
          ctx.fillText("", width / 2 - textWidth / 2, height / 2);

          // Create the refresh button
          // const image = document.createElement("img");
          // image.src = "sync.png"; // Replace "sync.png" with the actual path to your image file
          // image.style.height = "20px";

          // Create refresh button
          const refreshButton = document.createElement("button");
          refreshButton.textContent = "Retry";
          refreshButton.style.backgroundColor = "#052136";
          refreshButton.style.border = "2px solid #51e9fb";
          refreshButton.style.boxShadow = "inset 0 0 10px #aaf1fe";
          refreshButton.style.color = "aliceblue";
          refreshButton.style.padding = "0.2em 0.5em 0.2em 0.5em";
          refreshButton.style.display = "flex";
          refreshButton.style.justifyContent = "center";
          refreshButton.style.height = "70px";
          refreshButton.style.position = 'static';
          refreshButton.style.width = "175px";
          refreshButton.style.textAlign = "center";

          // Add event listener to refresh button
          refreshButton.onclick = function () {
            location.reload();
          };

          // Create container for image and button
          const container = document.createElement("div");
          container.style.display = "flex";
          container.style.alignItems = "center";
          container.style.justifyContent = "center";
          container.style.margin = '0 10px';
          container.appendChild(refreshButton);

          const anchorButton = document.createElement("button");
          anchorButton.textContent = "Menu";
          anchorButton.style.backgroundColor = "#052136";
          anchorButton.style.height = "70px";
          anchorButton.style.width = "175px";
          anchorButton.style.border = "2px solid #51e9fb";
          anchorButton.style.boxShadow = "inset 0 0 10px #aaf1fe";
          anchorButton.style.color = "aliceblue";
          anchorButton.style.padding = "0.2em 0.5em 0.2em 0.75em";
          anchorButton.style.display = "flex";
          anchorButton.style.justifyContent = "center";
          anchorButton.style.position = 'static';
          anchorButton.style.textAlign = 'center';

          // Add event listener to refresh button
          anchorButton.onclick = function () {
            window.location.href = "menu.html";
          };

          // Create container for image and button
          const anchorContainer = document.createElement("div");
          anchorContainer.style.display = "flex";
          anchorContainer.style.alignItems = "center";
          anchorContainer.style.justifyContent = "center";
          anchorContainer.style.margin = '0 10px';
          anchorContainer.appendChild(anchorButton);

          // Create a new div to contain both container and anchorContainer
          const flexContainer = document.createElement("dialog");
          flexContainer.style.display = 'flex';
          flexContainer.style.flexDirection = 'column';
          flexContainer.style.justifyContent = 'center';
          flexContainer.appendChild(container);
          flexContainer.appendChild(anchorContainer);

          // Append the flex container to the document body
          document.body.appendChild(flexContainer);
          flexContainer.showModal();

          // Create the anchor button
          // const anchorButton = document.createElement("a");
          // anchorButton.textContent = "Home";
          // anchorButton.href = "./menu.html"; // Replace with the desired URL
          // anchorButton.style.position = "absolute";
          // anchorButton.style.top = "60%";
          // anchorButton.style.left = "50%";
          // anchorButton.style.transform = "translate(-50%, -50%)";
          // document.body.appendChild(anchorButton);
        }
      }

      class Balls {
        constructor(state) {
          this.balls = range(state.ballCount).map(
            (i) => new Ball(2, state.ballPos.x, state.ballPos.y)
          );
          this.onBallStop = (ball) => {
            if (!state.firstBallStop) {
              state.ballPos = ball.position.copy();
              state.firstBallStop = true;
            }

            ball.position.x = state.ballPos.x;
          };
          this.balls.forEach((ball) => ball.setOnStop(this.onBallStop));
        }

        collideWithBricks(bricks) {
          bricks.bricks.forEach((brick) => {
            this.balls.forEach((ball) => {
              var audioElement = document.getElementById("brickTouchSound");
              // sd = this.n + 1;
              const collided = ball.collideWith(brick);
              if (collided) {
                audioElement.play();
                brick.hit();
              }
            });
          });
        }

        collideWithBonusBall(bonusBalls) {
          this.balls.forEach((ball) => {
            bonusBalls.forEach((bonusBall) => {
              const collided = ball.collideWithBonusBall(bonusBall);
              if (collided) bonusBall.hitWithBall();
            });
          });
        }

        get allStopped() {
          return this.balls.every((ball) => ball.velocity.mag() === 0);
        }

        addBalls(state, n) {
          const newBalls = range(n).map(
            (i) => new Ball(2, state.ballPos.x, state.ballPos.y)
          );
          newBalls.forEach((ball) => ball.setOnStop(this.onBallStop));
          this.balls.push(...newBalls);
        }

        async shoot(mousePos, state) {
          for (const ball of this.balls) {
            if (state.ballDowning) return;
            ball.shoot(mousePos);
            await delay(Math.max(50 - ~~(state.ballCount / 10), 0));
          }
        }

        display() {
          this.balls.forEach((ball) => {
            ball.update();
            ball.checkEdges();
            ball.display();
          });
        }

        down() {
          this.balls.forEach((ball) => ball.down());
        }
      }

      class Bricks {
        constructor() {
          this.bricks = [];
          this.particleSystems = new BrickParticleSystems();
        }

        addBricks(state, newBrickIndeces) {
          // console.log(newBrickIndeces);
          const newBricks = newBrickIndeces.map(
            (i) => new Brick(state.level, i, 0)
          );
          this.bricks.push(...newBricks);
        }

        display(state) {
          this.bricks.forEach((brick) => {
            brick.update(state); // Move down after fire
            brick.display(state);
          });

          this.particleSystems.run();
        }

        stopSound(sound) {
          sound.pause();
          sound.currentTime = 0;
        }

        break() {
          const bombBroken = this.bricks.findIndex((brick) => brick instanceof BombBrick && brick.broken) > -1;
          const brokenBricks = bombBroken ? this.bricks : this.bricks.filter((brick) => brick.broken);
          this.particleSystems.addParticleSystem(...brokenBricks);

          // Filter out the broken bricks
          this.bricks = bombBroken ? [] : this.bricks.filter((brick) => !brick.broken);
        }

        shouldSlideDown(state) {
          return this.bricks[0] && this.bricks[0].shouldMoveDown(state);
          return audioElement.stop();
          return true;
        }

        get hitBottom() {
          return this.bricks[0] && this.bricks[0].hitBottom;
        }
      }

      class BonusBalls {
        constructor() {
          this.bonusBalls = [];
        }

        addBonusBalls(state, newBonusBallIndex) {
          this.bonusBalls = [
            ...this.bonusBalls,
            new BonusBall(state.level, newBonusBallIndex, 0),
          ];
        }

        display(state) {
          this.bonusBalls.forEach((bonusBall) => {
            bonusBall.update(state);
            bonusBall.display();
          });
        }

        collideWithBall(balls) {
          this.bonusBalls.forEach((bonusBall) =>
            balls.balls.forEach((ball) => bonusBall.collideWith(ball))
          );
        }

        removeHitBalls() {
          this.bonusBalls = this.bonusBalls.filter(
            (b) => !b.hit || b.y > height
          );
        }

        get hitBallCount() {
          return this.bonusBalls.filter((ball) => ball.hit).length;
        }
      }

      class LocalStorageManager {
        constructor() {
          this.bestScoreKey = "brickBestScore";
          this.musicKey = "bricksMusic";
          this.soundKey = "bricksSound";
          this.storage = window.localStorage;
        }

        getBestScore() {
          return this.storage.getItem(this.bestScoreKey) || 1;
        }

        setBestScore(score) {
          this.storage.setItem(this.bestScoreKey, score);
        }

        setScore(score) {
          this.setBestScore(Math.max(score, this.getBestScore()));
        }

        getMusic() {
          return this.storage.getItem(this.musicKey) || true;
        }

        setMusic(music) {
          this.storage.setItem(this.musicKey, music);
        }

        getSound() {
          return this.storage.getItem(this.soundKey) || true;
        }

        setSound(sound) {
          this.storage.setItem(this.soundKey, sound);
        }
      }

      class GameManager {
        constructor() {
          this.state = {
            ballPos: new Vector(width / 2, height - 100),
            ballMoving: false,
            ballCount: 1,
            ballDowning: false,
            brickMoving: false,
            firstBallStop: true,
            level: 1,
            over: false,
          };
          const canvasWidth = 700;
          this.balls = new Balls(this.state);
          this.bricks = new Bricks();
          this.bonusBalls = new BonusBalls();
          this.ballLine = new BallLine();
          // ballLine.display(state);
          this.ui = new UI();
          this.scoreStorage = new LocalStorageManager();
          this.state.bestLevel = this.scoreStorage.getBestScore();

          // Music, Sound
          var bgMusic = document.getElementById('bgMusic');
          if(this.scoreStorage.getMusic() == 'false') {
            document.querySelector('.musicBtn img').src = 'no-music.png';
            bgMusic.pause();
          } else {
            bgMusic.play();
          }

          if(this.scoreStorage.getSound() == 'false') {
            document.querySelector('.soundBtn img').src = 'no-sound.png';
            var audioElementTouch = document.getElementById('brickTouchSound');
            var audioElementBreak = document.getElementById('brickBreakSound');
            audioElementTouch.muted = true;
            audioElementBreak.muted = true;
          }

          this.addBallsAndBricks();

          let canvas1 = canvas.addEventListener("mouseup", (e) =>
            this.shootBalls(e)
          );
          let canvas_touch = canvas.addEventListener("touchend", (e) =>
            this.shootBalls(e)
          );
          let slider = document.getElementById("myRange");
          if (canvas_touch == true && canvas1 == true) {
            slider.hidden = true;
          }
          slider.addEventListener("touchend", (e) => this.shootBalls(e));
          // slider.addEventListener("drag", (e) => this.shootBalls(e));
        }

        addBallsAndBricks() {
          const bonusBallCount = this.bonusBalls.hitBallCount;
          const newBrickIndeces = shuffle(range(7)).slice(0, randomInt(2, 6));

          const newBonusBallIndex = shuffle(
            range(6).filter((i) => !newBrickIndeces.includes(i))
          )[0];

          if (this.state.level % 8 === 0) {
            const bombBrickIndex = shuffle(
              range(7).filter(
                (i) => !newBrickIndeces.includes(i) && i !== newBonusBallIndex
              )
            )[0];

            if(bombBrickIndex !== undefined && bombBrickIndex >=0) {
              this.bricks.addBricks(this.state, [bombBrickIndex], true); // Pass true to create a BombBrick
            }
          }

          this.state.ballCount += bonusBallCount;
          this.balls.addBalls(this.state, bonusBallCount);
          this.bricks.addBricks(this.state, newBrickIndeces, false); // Pass false to create a regular Brick
          this.bonusBalls.addBonusBalls(this.state, newBonusBallIndex);
        }

        shootBalls(e) {
          if (
            this.state.ballMoving ||
            this.state.brickMoving ||
            this.state.over
          )
            return;

          this.state.ballPos = null;
          this.state.ballMoving = true;
          this.state.ballDowning = false;
          this.state.firstBallStop = false;

          const { x, y } = Mouse.position;
          this.balls.shoot({ x, y: Math.min(y, 1220) }, this.state);
        }

        checkCollision() {
          this.balls.collideWithBricks(this.bricks);
          this.bonusBalls.collideWithBall(this.balls);
          this.bricks.break();
        }

        draw() {
          let canWidth = 700;
          clear();
          // this.ballLine.display(this.state, canWidth);
          this.ballLine.display(this.state);
          this.balls.display();
          this.bricks.display(this.state);
          this.bonusBalls.display(this.state);
          this.ui.display(this.state);
        }

        run() {
          if(this.state.over) {
            return;
          }
          this.draw();
          this.checkCollision();
          const audioElement = document.getElementById("brickBreakSound");
          if (this.state.ballMoving && this.balls.allStopped) {
            this.state.ballMoving = false;
            this.state.brickMoving = true;

            this.state.level += 1;
            this.scoreStorage.setScore(this.state.level);
            this.state.bestLevel = this.scoreStorage.getBestScore();

            this.addBallsAndBricks();
          }

          // Slowly down the bricks
          // this.bricks.bricks.forEach((brick) => {
          //   brick.y += 0.2;
          // });

          if (this.state.brickMoving && this.balls.allStopped) {
            if (!this.bricks.shouldSlideDown(this.state)) { // Move Down after fire
              this.state.brickMoving = false;
              this.bonusBalls.removeHitBalls();
            }
          }

          if (this.bricks.hitBottom) {
            this.ui.gameOver();
            this.state.over = true;
          }

          window.requestAnimationFrame(() => this.run());
        }

        downBalls() {
          this.state.ballDowning = true;
          this.balls.down();
        }
      }

      Bricks.prototype.addBricks = function (
        state,
        newBrickIndeces,
        isBomb = false
      ) {
        let minY;
        if(this.bricks.length) {
          minY = this.bricks[this.bricks.length - 1].y - 100;
        }
        const newBricks = newBrickIndeces.map((i) => {
          if (isBomb) {
            return new BombBrick(state.level, i, 0, minY);
          } else {
            return new Brick(state.level, i, 0, minY);
          }
        });
        this.bricks.push(...newBricks);
      };

      Bricks.prototype.break = function () {
        // Check if there is a bomb brick
        const bombBrick = this.bricks.findIndex(
          (brick) => brick instanceof BombBrick && brick.broken
        ) > -1;
        const brokenBricks = bombBrick ? this.bricks : this.bricks.filter((brick) => brick.broken);
        this.particleSystems.addParticleSystem(...brokenBricks);

        // Filter out the broken bricks
        this.bricks = bombBrick ? [] : this.bricks.filter((brick) => !brick.broken);


        // if (bombBrick) {
          // Destroy all bricks, including the bomb brick
          // this.bricks = [];
          // Add particle systems for all bricks
          // this.particleSystems.addParticleSystem(...this.bricks);
        // }
      };

      canvas.addEventListener("mousemove", (e) => {
        const scale = ctx.scale;
        const offset = ctx.offset;
        const mx = e.pageX - canvas.offsetLeft;
        const my = e.pageY;

        Mouse.position = new Vector(mx, my);
      });

      function eventPos(e) {
        if (e.type.indexOf("touch") === -1) {
          // if its a mouse coord
          return { x: e.pageX, y: e.pageY, width: 1, height: 1 };
        }

        // touch event coord
        if (e.type === "touchend") return { x: 0, y: 0, width: 0, height: 0 };
        // return { x: e.touches[0].pageX * window.devicePixelRatio, y: e.touches[0].pageY * window.devicePixelRatio - 35, width: 70, height: 70 }
        const canvasRect = e.target.getBoundingClientRect();
        const touchX = e.touches[0].clientX - canvasRect.left;
        const touchY = e.touches[0].clientY - canvasRect.top;

        return {
          x: touchX * (canvas.width / canvasRect.width),
          y: touchY * (canvas.height / canvasRect.height),
          width: 70,
          height: 70,
        };
      }
      function eventPos1(e) {
        if (e.type.indexOf("touch") === -1) {
          // if its a mouse coord
          return { x: e.pageX, y: e.pageY, width: 1, height: 1 };
        }

        // touch event coord
        if (e.type === "touchend") return { x: 0, y: 0, width: 0, height: 0 };
        // return { x: e.touches[0].pageX * window.devicePixelRatio, y: e.touches[0].pageY * window.devicePixelRatio - 35, width: 70, height: 70 }
        const canvasRect = e.target.getBoundingClientRect();
        const touchX = e.touches[0].clientX - canvasRect.left;
        const touchY = e.touches[0].clientY - canvasRect.top;

        return {
          x: touchX * (canvas.width / canvasRect.width),
          y: 800,
          width: 700,
          height: 700,
        };
      }

      function touchMove(e) {
        e.preventDefault(); // Prevent default touch event behavior
        const scale = ctx.scale;
        const offset = ctx.offset;
        const pos = eventPos(e);
        const mx = pos.x;
        const my = pos.y;

        Mouse.position = new Vector(mx, my);
      }

      function touchMove1(e) {
        e.preventDefault(); // Prevent default touch event behavior
        const scale = ctx.scale;
        const offset = ctx.offset;
        const pos = eventPos(e);
        const mx = pos.x;
        const my = pos.y - 800;
        Mouse.position = new Vector(mx, my);
        // Mouse.position = new Vector(negx, negy);
      }

      canvas.addEventListener("touchstart", touchMove);
      canvas.addEventListener("touchmove", touchMove);

      const gameManager = new GameManager();

      gameManager.run();
      let slider = document.getElementById("myRange");
      slider.addEventListener("touchend", (e) => this.shootBalls(e));
      slider.addEventListener("mouseup", (e) => this.shootBalls(e));
      slider.addEventListener("input", touchMove(e));
      slider.oninput = function () {
        addEventListener("touchstart", touchMove);
        addEventListener("touchmove", touchMove);
      };
    </script>
    <!-- <script src="Mute.js"></script> -->
    <script
      src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/js/bootstrap.bundle.min.js"
      integrity="sha384-C6RzsynM9kWDrMNeT87bh95OGNyZPhcTNXj1NW7RuBCsyN/o0jlpcV8Qyq46cDfL"
      crossorigin="anonymous"
    ></script>
    <script>
      const dialog = document.querySelector("dialog");
      const showButton = document.querySelector("dialog + button");
      const closeButton = document.querySelector("dialog button");

      // "Show the dialog" button opens the dialog modally
      // showButton.addEventListener("click", () => {
      //   dialog.showModal();
      // });

      // "Close" button closes the dialog
      closeButton.addEventListener("click", () => {
        dialog.close();
      });

      // refreshBtn = document.getElementById("refreshBtn");
      // refreshBtn.addEventListener("click", () => {
      //   setTimeout(() => {
      //     var bgMusic = document.getElementById("bgMusic");
      //     bgMusic.play();
      //   }, 1000);
      // });
    </script>
    <script src="gameMusic.js"></script>
  </body>
</html>
